#!/usr/bin/env python
# -*- coding: utf-8 -*-
#Lasa-modified: 28 Apr 2015 04:17:05 PM

#########################################################################
#         Module/Scripts Description
# 
# Copyright (c) 2014 Yunfei Wang <Yunfei.Wang1@utdallas.edu>
# 
# This code is free software; you can redistribute it and/or modify it
# under the terms of the BSD License (see the file COPYING included with
# the distribution).
# 
# @status:  experimental
# @version: 1.1.0
# @author:  Yunfei Wang
# @contact: yfwang0405@gmail.com
#########################################################################

# ------------------------------------
# python modules
# ------------------------------------

import os
import sys
import bisect
import shutil
import argparse
import tempfile
import functools
import collections
import pkg_resources
from multiprocessing import Pool, freeze_support, Lock, Value

# external package
import numpy

# 
import rsq
import ngslib



# ------------------------------------
# constants and globals
# ------------------------------------

# debug option
rsq.debug = False
debug = False
counter = None
lock = None

const_dict = {'|':{'|':'|','x':'.','.':'|'}, 'x':{'x':'x','.':'x','|':'.'},'.':{'.':'.','x':'x','|':'|'}}

# ------------------------------------
# Misc functions
# ------------------------------------

def ArgParser(arglst):
    parser=argparse.ArgumentParser(prog='rsq',usage=argparse.SUPPRESS,description="Program: %(prog)s {0} (Python Package for RNA structurome quantification using RNA footprinting data.)".format(version()),epilog='dependency rsq, ngslib')

    options = parser.add_argument_group('Sub commands')
    options.add_argument('genFastD', help='Generate FastD format file.')
    options.add_argument('FastC', help='FastC format utilities.')
    options.add_argument('FastS', help='FastS format utilities.')
    options.add_argument('isoform', help="Deal with isoform cases.")
    options.add_argument('quantify', help='Quantification of RNA structures.')
    options.add_argument('draw', help='Draw RNA secondary structures.')
    options.add_argument('fitness',help="Fitness between sequencing depth (FastD) and structure (FastS).")
    
    
    # Sub commands parsers
    par_dict = {None:parser}
    
    ##################################################
    # Sub command: FastD
    ##################################################
    P = argparse.ArgumentParser(prog='rsq genFastD',description="Program: %(prog)s (Generating FastD format data.)",epilog='dependency rsq,ngslib')

    options =  P.add_argument_group('Sub commands')

    #options.add_argument('generate', help='Generating FastD file from Next-Generation sequencing data.')
    #options.add_argument('merge', help='Merge FastD files based on predefined weights.')

    # FastD generate
    #p = argparse.ArgumentParser(prog='rsq FastD generate',description="Program: %(prog)s (Generating FastD format data.)",epilog='dependency rsq,ngslib')

    options = P.add_argument_group('Input options')
    options.add_argument("-a","--annotation",dest="annofile",type=str,metavar="sacCer2_SGDother.gpd", required=False,default=None,help="Gene annotation file in GenePred (.gpd) format. See UCSC genePred format for details.")
    options.add_argument("-i","--interested",dest='ibed',type=str,metavar="interested.bed",required=True,help="Interested Bed regions for structures quantification.")
    options.add_argument("-g","--genome",dest="gfile",type=str,metavar="sacCer2.fa",required=False,default=None,help="Genome file in Fasta format.")
    options.add_argument("-S","--single-prefix",dest="dS",type=str,metavar="sacCer_SS",required=False,nargs='+',default=[],help="Prefixes of BigWig files for single-strand depth in format: prefix_plus.bw and prefix_minus.bw.")
    options.add_argument("-D","--double-prefix",dest="dV",type=str,metavar="sacCer_DS",required=False,nargs='+',default=[],help="Prefixes of BigWig files for doublestrand depth in format: prefix_plus.bw and prefix_minus.bw.")

    # general parameters
    paras = P.add_argument_group('Parameters')
    paras.add_argument("-d","--depth",dest="depth",type = int,metavar="5",required=False,default=5,help="Minimum coverage depth. For data has either stem or loop data, depth = #reads / RNA_length. For data has both stem and loop, depth = (#stems+#loops) / RNA_length. [default = 5]")
    paras.add_argument("-m","--method",dest="method",type=str,choices=('truncate','extend'),default='truncate',help="Transcripts grouping method. Default is 'truncate'.")
    #paras.add_argument("-t","--ntrim",dest="ntrim",type=int,metavar="5",required=False,default=5,help="Number of bases trimmed at both ends. [default = 5]")
    paras.add_argument("-l","--length",dest="length",type=int,metavar="3000",required=False,default=3000,help="Maximum sequence length. Longer sequences are not included in output files. Set '0' if no limitation. [default = 3000]")
    paras.add_argument("-wS","--Sweights",dest="Sweights",type=float,metavar="0.5",nargs='+',required=False,default=[],help="Weights for single-strand replicates. Weight ranges in [0,1]. NOTE: sum(weights) dosen't need to be 1. [default = [1.0, ..., 1.0]].")
    paras.add_argument("-wV","--Vweights",dest="Vweights",type=float,metavar="0.5",nargs='+',required=False,default=[],help="Weights for double-strand replicates. Weight ranges in [0,1]. NOTE: sum(weights) dosen't need to be 1. [default = [1.0, ..., 1.0]].")
    #paras.add_argument("-n","--normalize",dest="norm",action="store_true",required=False,help="If specified, loops and stems are normalized to equal depth globally. Otherwise, keep original values.")
    # paras.add_argument("-c","--constraints",dest="constratints",action="store_true",default=True,help="Calculate constraints.")
   
    # Output
    output = P.add_argument_group('Output')

    output.add_argument("-o","--output",dest="outfile",type=str,metavar="sacCer2.fd",required=False,default="stdout",help="Output file. Default is stdout.")
    par_dict['genFastD'] = {None:P}


    ##################################################
    # FastC
    ##################################################
    
    P = argparse.ArgumentParser(prog='rsq FastC',usage=argparse.SUPPRESS,description="Program: %(prog)s (Generating FastC format data.)",epilog='dependency rsq,ngslib')
    
    options =  P.add_argument_group('Sub commands')
    options.add_argument('generate', help='Generating FastC file from Next-Generation sequencing data.')
    options.add_argument('merge', help='Merge FastC files.')
    par_dict['FastC'] = {None:P}

    # FastC generate
    p = argparse.ArgumentParser(prog='rsq FastC generate',description="Program: %(prog)s (Generating FastC format data.)",epilog='dependency rsq')

    options = p.add_argument_group('Input options')
    options.add_argument("-i",dest="infile",type=str,metavar="sce_genes.fd", required=True,help="Gene sequence in FastD format.")
    options.add_argument("-m", "--method",dest="method",type=str,choices=['p','f','l','e','n'],default='fisher',help="Methods to convert FastD data to FastC format. 'p' for 'percentile', 'f' for 'fisher exact test', 'l' for 'log2(S+1)/(V+1)','e' for 'exclusive' and 'n' for 'none'.")
    options.add_argument("-st","--sthreshold",dest="sthreshold",type=float,metavar=0.05,required=False,default=0.05,help="Threshold for S1 (loops) data.")
    options.add_argument("-vt","--vthreshold",dest="vthreshold",type=float,metavar=0.05,required=False,default=0.05,help="Threshold for V1 (stems) data.")
   
    # Output
    output = p.add_argument_group('Output')

    output.add_argument("-o","--output",dest="outfile",type=str,metavar="sacCer2.fc",required=False,default="stdout",help="Output file. Default is stdout.")
    par_dict['FastC']['generate'] = {None:p}


    # FastC merge
    p = argparse.ArgumentParser(prog='rsq FastC merge',description="Program: %(prog)s (Merge FastC files.)",epilog='dependency rsq')
    options = p.add_argument_group('Input options')
    options.add_argument("-i","--infiles",dest="infiles",type=str,metavar="sample.fc",nargs='+',required=True,help="A list of FastC files.")
    options.add_argument("-m","--method",dest="method",type=str,choices=['i','u'],default='i',help="Method used to merge constraints.'i' for interstion and 'u' for union.")

    # Output
    output = p.add_argument_group('Output')
    output.add_argument("-o","--output",dest="outfile",type=str,metavar="merged.fc",required=False,default="stdout",help="Output file. Common constraints are shown in the output file.")
    par_dict['FastC']['merge'] = {None:p}


    ##################################################
    # FastS
    ##################################################
    P = argparse.ArgumentParser(prog='rsq FastS',usage=argparse.SUPPRESS,description="Program: %(prog)s (FastS format utilities.)",epilog='dependency rsq')
    
    options =  P.add_argument_group('Sub commands')
    #options.add_argument('extend', help='Extend FastS format to EFastS format using gene annotation information.')
    options.add_argument('generate', help='Merge FastS files.')
    options.add_argument('merge', help='Merge FastS files.')
    par_dict['FastS'] = {None:P}

    # generate FastS
    p = argparse.ArgumentParser(prog='rsq fold',description="Program: %(prog)s (Fold RNA structures given FastC constraints.)",epilog='dependency rsq,ngslib')

    options = p.add_argument_group('Input options')
    options.add_argument("-i","--infile",dest="infile",type=str,metavar="sce_genes.fc", required=True,help="Constraints in FastC format.")
    #options.add_argument("-m", "--methods",dest="methods",type=str,nargs="+",choices=['sfold','RNAfold','mfold'],default='sfold ',help="Methods to fold RNA structures.")
    options.add_argument("-p","--processors",dest="p",type=int,metavar=10,required=False,default=10,help="Number of processors to run. [Default = 10].")
    options.add_argument("-n","--nstructures",dest="n",type=int,metavar=1000,required=False,default=1000,help="Number of structures sampled by Sfold. [Default = 1000].")
   
    # Output
    output = p.add_argument_group('Output')
    output.add_argument("-w","--workdir",dest="wdir",type=str,metavar="./workdir",required=False,default="./workdir",help="Directory for Sfold temporary files. [Default is './workdir']")
    output.add_argument("-k","--keep",dest="keep",action="store_true",required=False,default=False,help="Keep the temporary files if specified.")
    output.add_argument("-o","--outfile",dest="outfile",type=str,metavar="out.fs",default="stdout",required=False,help="Sfold output file. Default is standard output.")
    par_dict['FastS']['generate'] = {None:p}

    # Merge FastS files
    p = argparse.ArgumentParser(prog='rsq FastS merge',description="Program: %(prog)s (Merge FastS files.)",epilog='dependency rsq')

    options = p.add_argument_group('Input options')
    options.add_argument("-i","--infiles",dest="infiles",type=str,metavar="sample.fs", nargs="+",required=True,help="FastS files.")
    #options.add_argument("-c","--clustering",dest='clust',action='store_true',default=False,help="Do clustering and use the centroids as candidate structures. No clustering if not specified..")

    options = p.add_argument_group('Output options')
    options.add_argument("-o","--outfile",dest="outfile",type=str,metavar="merged.fs", default="stdout", required=False,help="Merged FastS file.")

    par_dict['FastS']['merge'] = {None:p}


    ##################################################
    # isoform
    ##################################################

    P = argparse.ArgumentParser(prog='rsq isoform',description="Program: %(prog)s (Deal with isoform cases.)",epilog='dependency rsq,ngslib')
    options =  P.add_argument_group('Sub commands')
    options.add_argument('extend', help='Extend FastD and FastS formats.')
    options.add_argument('split',help="Split EfastD/S formats back into FastD/S formats.")
    par_dict['isoform'] = {None:P}

    p = argparse.ArgumentParser(prog='rsq isoform extend',description="Program: %(prog)s (Extend FastD and FastS formats to EFastD and EFastS formats using gene annotation information.)",epilog='dependency rsq,ngslib')

    # Extend FastD/S format
    options = p.add_argument_group('Input options')
    options.add_argument("-d","--fdfile",dest="fdfile",type=str,metavar="sce_genes.fd", required=True,help="FastD file.")
    options.add_argument("-s","--fsfile",dest="fsfile",type=str,metavar="sce_genes.fs", required=True,help="FastS file.")
    options.add_argument("-g","--geneanno",dest="ganno",type=str,metavar="sce_genes.gpd", required=True,help="Gene annotation file in GenePred format.")

    options = p.add_argument_group('Output options')
    options.add_argument("-p","--prefix",dest="prefix",type=str,metavar="sce_gene", required=False,help="Prefix of output files. prefix.efd/efs are the extended FastD/S file. prefix.isf is the isoform information.")

    par_dict['isoform']['extend'] = {None:p}

    p = argparse.ArgumentParser(prog='rsq isoform split',description="Program: %(prog)s (Split EFastD and EFastS formats to FastD and FastS formats.)",epilog='dependency rsq,ngslib')

    # Extend FastD/S format
    options = p.add_argument_group('Input options')
    options.add_argument("-i","--isffile",dest="isffile",type=str,metavar="sce_genes.isf", required=True,help="isoform file.")
    options.add_argument("-s","--efsfile",dest="efsfile",type=str,metavar="sce_genes.efs", default=None,required=False,help="FastS file.")
    options.add_argument("-d","--efdfile",dest="efdfile",type=str,metavar="sce_genes.efd", required=True,help="FastD file.")

    options = p.add_argument_group('Output options')
    options.add_argument("-p","--prefix",dest="prefix",type=str,metavar="sce_gene", required=False,help="Prefix of output files. By default is the prefix of the FastS file.")

    par_dict['isoform']['split'] = {None:p}


    ##################################################
    # quantify
    ##################################################

    p = argparse.ArgumentParser(prog='rsq quantify',description="Program: %(prog)s (Quantify RNA structures given RNA footprinting data in FastD format.)",epilog='dependency rsq,ngslib')

    options = p.add_argument_group('Input options')
    options.add_argument("-d","--fdfile",dest="fdfile",type=str,metavar="sce_genes.fd", required=True,help="RNA footprinting data in FastD format.")
    options.add_argument("-s","--fsfile",dest="fsfile",type=str,metavar="sce_genes.fs", required=True,help="RNA structure in FastS format.")
    options.add_argument("-i","--isoform",dest="isoform",type=str,metavar="sce_genes.isf",required=False,default=None,help="Transcript isoform information. Required only when isoforms are considered.")
    options.add_argument("-e","--expression",dest="expression",type=str,metavar='sce_genes.eprs',required=False,default=None,help='Expression levels from gene expression data. Effective only in isoform case. Format for each line: geneid\\isoform1\\tRPKM\\tisoform2\\tRPKM\\t...')
    options.add_argument("-m", "--maxiter",dest="maxiter",type=int,metavar="100",required=False,default=100,help="Maximum number of iteration for EM algorithm. Default is 100.")
    options.add_argument("-t","--threshold",dest="threshold",type=float,metavar="1e-6",required=False,default=1e-6,help="Threshold for EM algorithm termination.")
   
    # Output
    output = p.add_argument_group('Output')
    output.add_argument("-o","--outfile",dest="outfile",type=str,metavar="out.txt",default="stdout",required=False,help="Quantification output file.")

    par_dict['quantify'] = {None:p}


    ##################################################
    # fitness
    ##################################################
    
    
    p = argparse.ArgumentParser(prog='rsq fitness',description="Program: %(prog)s (Fitness between sequencing depth (FastD) and structure (FastS).)",epilog='dependency rsq,ngslib')

    options = p.add_argument_group('Input options')
    options.add_argument("-d","--FastD",dest="fdfile",type=str,metavar="sce_genes.fd", required=True,help="Gene sequence in FastD format.")
    options.add_argument("-s","--fsfile",dest="fsfile",type=str,metavar="sce_genes.fs", required=True,help="Structures in FastS format.")
    options.add_argument("-c","--coverage",dest="coverage",type=float,metavar=5,required=False,default=5,help="Minimum FastD coverage. [default = 5].")
    options.add_argument("-t","--threshold",dest="threshold",type=float,metavar=0.1,required=False,default=0,help="Percentage threshold.Only structures with percentage > threshold are considered.Set to 0 when all the structures are wanted irrespective of the scores.")
    options.add_argument("-b","--byseq",dest="byseq",action="store_true",default=False,required=False,help="If set, find common items between FastD and FastS by gene sequences instead of gene names.")
   
    # Output
    output = p.add_argument_group('Output')
    output.add_argument("-o", "--outfile",dest="outfile",type=str,metavar='outfile',default="stdout",required=False,help="Output file name. [default = stdout].")
    par_dict['fitness'] = {None:p}


    ##################################################
    # draw
    ##################################################
    # Draw RNA secondary structures.
    p = argparse.ArgumentParser(prog='rsq draw',description="Program: %(prog)s (Draw RNA secondary structures.)",epilog='dependency rsq')

    options = p.add_argument_group('Input options')
    options.add_argument("-i","--infile",dest="infile",type=str,metavar="sce_genes.fs", required=True,help="RNA structure in FastS format.")
    options.add_argument("-f","--format",dest="format",type=str,metavar="ps",default="ps",choices=['svg','ps'],help="Secondary structure file format. Default is ps format.")
   
    # Output
    output = p.add_argument_group('Output')
    output.add_argument("-s","--suffix",dest="suffix",type=str,metavar="suffix",required=False,default=None,help="suffix of output file name in 'genename_suffix-i.format'. Default is no suffix.")

    par_dict['draw'] = {None:p}

    
    #Parse arglst
    nl = len(arglst)
    
    P = par_dict
    i = 1
    while True:
        if i == nl:
            sys.exit(P[None].print_help())
        if P.has_key(arglst[i]):
            P = P[arglst[i]]
            i += 1
        else:
            try:
                args = P[None].parse_args(arglst[i:])
            except:
                sys.exit(P[None].print_help())
            return arglst[1:i],args
    assert True, "Not reach this line."
    return

def fastDGenerate(args):
    '''
    Generate FastD file. NOTE: Transcripts with duplicate names are ignored.
    
    Input options:
        args.annofile: string, *.genepred
            Gene annotation file in Bed or GenePred format. See UCSC gene format for details.
        args.ibed: string, *.bed
            Interested Bed regions for structure quantification.     
        args.gfile: string, *.fa
            Genome file in Fasta format.
        args.dS: string, *.wig or *.bw
            Wiggle file or bigwig file containing loop (S) information.
        args.dV: string, *.wig or *.bw
            Wiggle file or bigwig file containing stem (V) information.
    
    Parameters:
        args.depth: int
            Minimum average sequencing depth of interested region. [default= 5]
        args.method: string, choices from 'truncate' or 'extend'
            Transcripts grouping method. [default= 'truncate']
        args.length: int
            Maximum seqeuence length. Longer sequences will notincluded in output files. Set '0' if no limitation. [default= 3000]
    
    Output:
        args.outfile: string
            Output file. Default is stdout.
    '''
    # Input options
    if len(args.Sweights) != len(args.dS):
        if len(args.Sweights) == 0:
            args.Sweights = [1.0] * len(args.dS)
        else:
            raise ValueError("ERROR: lengths of weights {0} does not match to lengths of replicates {1}.".format(len(args.Sweights),len(args.dS)))
    if len(args.Vweights) != len(args.dV):
        if len(args.Vweights) == 0:
            args.Vweights = [1.0] * len(args.dV)
        else:
            raise ValueError("ERROR: lengths of weights {0} does not match to lengths of replicates {1}.".format(len(args.Vweights),len(args.dV)))
    # Processing genome file
    print >>sys.stderr, "Open genome and BigWig files ..."
    gdb = ngslib.DB(args.gfile,'fasta')
    # Processing depth file
    bwS = {'+':[],'-':[]}
    bwV = {'+':[],'-':[]}
    for f in args.dV:
        bwV['+'].append(ngslib.BigWigFile(f+'_plus.bw'))
        bwV['-'].append(ngslib.BigWigFile(f+'_minus.bw'))
    for f in args.dS:
        bwS['+'].append(ngslib.BigWigFile(f+'_plus.bw'))
        bwS['-'].append(ngslib.BigWigFile(f+'_minus.bw'))
    # Transcripts grouping
    print >>sys.stderr, "Generating FastD file ..."
    ofh = ngslib.mFile(args.outfile,'w')
    grpfh = ngslib.mFile(args.ibed[:-3]+'grp','w')
    dfilter = 0
    lfilter = 0
    total   = 0
    nfds    = 0
    passfilter = True
    for gene in TransGrouping(args.annofile,args.ibed,args.method):
        if ':' not in gene.id: # merged transcript
            print >>grpfh, gene
            # Filters
            l = gene.getcDNALength()
            print l
            depS = numpy.zeros(l)
            depV = numpy.zeros(l)
            for i,w in enumerate(args.Sweights):
                depS += gene.getWig(bwS[gene.strand][i])*w
            for i,w in enumerate(args.Vweights):
                depV += gene.getWig(bwV[gene.strand][i])*w
            passfilter = True
            total += 1
            if numpy.mean(depS+depV) < args.depth:
                dfilter += 1
                passfilter = False
            elif args.length != 0 and l > args.length:
                lfilter += 1
                passfilter = False
            continue
        # real transcript
        if passfilter:
            nfds += 1
            print >>grpfh, gene
            # get depths and sequence
            seq = gene.getSeq(gdb)
            l = gene.getcDNALength()
            depS = numpy.zeros(l)
            depV = numpy.zeros(l)
            for i,w in enumerate(args.Sweights):
                depS += gene.getWig(bwS[gene.strand][i])*w
            for i,w in enumerate(args.Vweights):
                depV += gene.getWig(bwV[gene.strand][i])*w
            print >>ofh, ">{0}\n{1}\n{2}\n{3}".format(gene.id,seq,
                                                      ';'.join([str(round(d,2)) for d in depS]) if max(depS) >0 else '+',
                                                      ';'.join([str(round(d,2)) for d in depV]) if max(depV) >0 else '+')
    ofh.close()
    gdb.close()
    grpfh.close()
    for key in bwV:
        for fh in bwV[key]:
            fh.close()
    for key in bwS:
        for fh in bwS[key]:
            fh.close()

    print >> sys.stderr, "A total of {0} Bed regions are processed.".format(total)
    print >> sys.stderr, "{0} item(s) failed to pass depth (>={1}) filter.".format(dfilter,args.depth)
    print >> sys.stderr, "{0} item(s) failed to pass length (<={1}) filter.".format(lfilter,args.length != 0 and args.length or 'Inf')
    print >> sys.stderr, "Finally {0} item(s) were written into {1}".format(nfds,args.outfile)
    print >> sys.stderr, "Gene groups were written into {0}grp.".format(args.ibed[:-3])

def TransGrouping(annofile,bedfile, method='truncate'):
    '''
    Group transcripts in annofile according to bedfile. 
    Parameters:
        annofile: string
            Annotation file in genepred format.
        bedfile: string
            Bed file of interested regions.
        method: string
            Choices from 'trucate' or 'extend'.
    '''
    annodb  = ngslib.DB(annofile,'genepred')
    # Read Bed file and group transcripts
    for bed in ngslib.IO.BioReader(bedfile,'bed'):
        exons = ngslib.BedList()
        trans = {}
        if method == 'extend': # extend
            start = bed.start
            end = bed.stop
            cnt = len(trans)
            while True: # extend
                for gene in annodb.fetch(bed.chrom,start,end,bed.strand,converter=ngslib.GeneBed):
                    if not trans.has_key(gene.id):
                        exons.extend(list(gene.exons()))
                        trans[gene.id] = gene
                        start = min(start,gene.start)
                        end   = max(end,gene.stop)
                if len(trans) > cnt:
                    cnt = len(trans)
                else:
                    break
        elif method == 'truncate': # truncate
            for gene in annodb.fetch(bed.chrom,bed.start,bed.stop,bed.strand,converter=ngslib.GeneBed):
                if gene.start < bed.start or gene.stop > bed.stop:
                    gene.id += '_truncated'
                starts = []
                stops  = []
                for exon in gene.exons():
                    if bed.overlapLength(exon)>0:
                        starts.append(max(exon.start,bed.start))
                        stops.append(min(exon.stop,bed.stop))
                # update gene
                starts.sort()
                stops.sort()
                gene.exonstarts = starts
                gene.exonstops  = stops
                gene.start = starts[0]
                gene.stop  = stops[-1]
                gene.txstart = max(gene.txstart,gene.start)
                gene.txstop  = min(gene.txstop,gene.stop)
                gene.exoncount = len(gene.exonstarts)
                if gene.exoncount:
                    exons.extend(gene.exons())
                    trans[gene.id] = gene
        else:
            raise ValueError("ERROR: Method '{0}' is not recognized. Choices are 'extend' or 'truncate'.".format(method))
        # Report transcripts
        mexons = exons.merge()
        starts, ends = zip(*[(exon.start,exon.stop) for exon in mexons])
        tr = ngslib.GeneBed([bed.id,bed.chrom,bed.strand,bed.start,bed.stop,bed.start,bed.stop,len(mexons),starts,ends])
        yield tr
        for tr in trans.values():
            tr.id = "{0}:{1}".format(bed.id,tr.id) # merge ID
            yield tr

def fastDMerge(args):
    '''
    Merge FastD files.
    Parameters:
        args.infiles: list of strings
            A list of FastD files
        args.weights: list of floats
            Weight for each FastD file
        args.outfile: string
            Output file.
    '''
    if len(args.infiles) != len(args.weights):
        raise ValueError("ERROR: number of files and weights do not match.")
    FD = collections.OrderedDict()
    for i in range(len(args.infiles)):
        weight = args.weights[i]
        for fd in rsq.IO.FastDReader(args.infiles[i]):
            if FD.has_key(fd.name):
                FD[fd.name].stems += fd.stems*weight
                FD[fd.name].loops += fd.loops*weight
            else:
                fd.loops *= weight
                fd.stems *= weight
                FD[fd.name] = fd
    # output
    with ngslib.mFile(args.outfile, 'w') as ofh:
        for name in FD:
            print >>ofh, FD[name]

def fastCGenerate(args):
    '''
    Calculate constraints using different methods from FastD file.
    '''
    with ngslib.mFile(args.outfile,'w') as ofh:
        i0 = 0
        print >> sys.stderr, "Start: reading items from {0} and writing output into {1} ...".format(args.infile,args.outfile)
        for fd in rsq.IO.FastDReader(args.infile):
            i0 += 1
            if i0%100 == 0:
                print >> sys.stderr, "Processed {0} items ...        \r".format(i0),
            ofh.write(str(fd.toFastC(args.method,args.sthreshold,args.vthreshold))+"\n")
        print >> sys.stderr, "Processed {0} items.\n".format(i0)
        print >> sys.stderr, "Done.\n"
    return

def fastCMerge(args):
    '''
    Merge FastC files.
    Parameters:
        args.infiles: list of strings
            A list of FastC files
        args.method: 'u' or 'i'
            'u' or union, and 'i' for 'intersection.
        args.outfile: string
            Output file.
    Output:
        Merged FastC file.
    Example:
        constraint 1: '..||..xx..'
        constraint 2: '.x|.x.|x..'
        union:      : '.x||x..x..' conflicting ones are set to '.'
        intersection: '..|....x..' only take common ones.
    '''
    FC = collections.OrderedDict()
    for i in range(len(args.infiles)):
        for fc in rsq.IO.FastCReader(args.infiles[i]):
            if FC.has_key(fc.name):
                if args.method == 'i': # intersection
                    idx = FC[fc.name].constraints != numpy.array(list(fc.constraints))
                    FC[fc.name].constraints[idx] = '.'
                else: # union
                    FC[fc.name].constraints = numpy.array([const_dict[a][b] for a,b in zip(FC[fc.name].constraints,fc.constraints)])
            else:
                fc.constraints = numpy.array(list(fc.constraints))
                FC[fc.name] = fc
    # output
    with ngslib.mFile(args.outfile, 'w') as ofh:
        for name in FC:
            FC[name].constraints = FC[name].constraints.tostring()
            print >>ofh, FC[name]

def isoformExtend(args):
    '''
    Extend FastD and FastS for genes with isoforms.
    Parameters:
        args.fdfile: string
            FastD file.
        args.fsfile: stirng
            FastS file
        args.ganno: string
            Gene annotation file in GenePred format.
        args.prefix: string
            Output prefix. By default use the prefix of FastD file
    '''
    # Read FastS file
    FSS = collections.OrderedDict()
    for fs in rsq.IO.FastSReader(args.fsfile):
        FSS[fs.name] = fs
        
    # Read FastD file
    FDS = collections.OrderedDict()
    for fd in rsq.IO.FastDReader(args.fdfile):
        if FSS.has_key(fd.name): # only count those transcript with structures
            FDS[fd.name] = fd     

    # Read GenePred annotation file.
    Isoforms = collections.OrderedDict() # {proteinid:[FastS,FastS,...]}
    Transcripts = collections.OrderedDict() # {transcript.id:transcript}
    for transcript in ngslib.IO.BioReader(args.ganno,'genepred'):
        if FSS.has_key(transcript.id) and transcript.proteinid != '': # only count transcript in FSS
            Isoforms.setdefault(transcript.proteinid,[])
            Isoforms[transcript.proteinid].append(FSS.pop(transcript.id)) # FastS
            Transcripts[transcript.id] = transcript # annotation
    # FastS file
    with ngslib.mFile(args.prefix+".efs", 'w') as ofh:
        with ngslib.mFile(args.prefix+".efd",'w') as fdfh:
            with ngslib.mFile(args.prefix+".isf",'w') as isffh:
                # transcripts have no protein id
                for key in FSS:
                    print >>ofh, FSS[key]
                    print >>fdfh, FDS[key]
                # transcripts have protein id
                for pid in Isoforms:
                    if len(Isoforms[pid]) == 1: # no isoform
                        print >>ofh, fs
                        print >>fdfs, FDS[fs.name]
                    else:
                        # Read exons
                        exons = ngslib.BedList()
                        mexons = ngslib.BedList()
                        for fs in Isoforms[pid]:
                            exons.extend(Transcripts[fs.name].exons())
                        exons.sort()
                        # Merge exons
                        starts = []
                        lengths = [0]
                        mexons.append(exons[0])
                        for exon in exons[1:]:
                            if exon.overlapLength(mexons[-1])>=0:
                                mexons[-1] += exon
                            else:
                                starts.append(mexons[-1].start)
                                lengths.append(len(mexons[-1])+lengths[-1])
                                mexons.append(exon)
                        starts.append(mexons[-1].start)
                        lengths.append(len(mexons[-1])+lengths[-1])
                        # Parse FastS, FastD
                        L = lengths[-1]
                        Sdepth = numpy.zeros(L)
                        Vdepth = numpy.zeros(L)
                        all_structures = []
                        all_scores = []
                        seq = numpy.repeat('N',L)
                        strand = Transcripts[Isoforms[pid][0].name].strand
                        lstr = pid
                        for fs in Isoforms[pid]:
                            fd = FDS[fs.name]
                            M = len(fs.scores)
                            lstr += "\t"+fs.name+":"+str(M)
                            transcript = Transcripts[fs.name]
                            structures = [numpy.repeat('-',L) for i in range(M)]
                            if strand == '-':
                                fs.rc()
                                fd.rc()
                            l = 0
                            # string to list
                            fs.seq = list(fs.seq)
                            fs.structures = [list(st) for st in fs.structures]
                            for estart,estop in zip(transcript.exonstarts,transcript.exonstops):
        
                                # Find overlapped exon
                                le = estop-estart
                                idx = bisect.bisect(starts,estart)
                                #if exon.start < starts[idx]:
                                idx -=1
                                start = lengths[idx]+ estart-starts[idx]
                                seq[start:(start+le)] = fs.seq[l:(l+le)]
                                Sdepth[start:(start+le)] = fd.loops[l:(l+le)]
                                Vdepth[start:(start+le)] = fd.stems[l:(l+le)]
                                for i in range(M):
                                    structures[i][start:(start+le)] = fs.structures[i][l:(l+le)]
                                l += le
                            all_structures.extend(structures)
                            all_scores.extend(fs.scores)
                        # print EFastS
                        nfs = rsq.FastS(pid,seq.tostring(),[st.tostring() for st in all_structures],all_scores)
                        if strand == '-':
                            nfs.rc()
                            Sdepth = Sdepth[::-1]
                            Vdepth = Vdepth[::-1]
                        print >> ofh, nfs
                        print >> fdfh, rsq.FastD(nfs.name,nfs.seq,Sdepth,Vdepth)
                        print >> isffh, lstr

def isoformSplit(args):
    '''
    Split EFastD/S into FastD/S.
    Parameters:
        args.isffile: string
            Isoform information, generated from 'isoform extend'
        args.efsfile: string
            Extened FastS file. generated from 'isoform extend'
        args.efdfile: string
            Extened Fastd file. generated from 'isoform extend'
        args.prefix: string
            Output prefix. Default is the prefix of args.efsfile.
    '''
    isf = collections.OrderedDict()
    for line in ngslib.mFile(args.isffile):
        items = line.split()
        isf[items[0]] = []
        for item in items[1:]:
            tid,nst = item.split(":")
            nst = int(nst)
            isf[items[0]].append((tid,nst))
    FDS = collections.OrderedDict()
    if args.efdfile:
        for efd in rsq.IO.FastDReader(args.efdfile):
            FDS[efd.name] = efd
        fdfh = ngslib.mFile(args.prefix+".fd",'w')
    with ngslib.mFile(args.prefix+".fs",'w') as fsfh:
        for efs in rsq.IO.FastSReader(args.efsfile):
            seq = numpy.array(list(efs.seq))
            cnt = 0
            for tid,nst in isf[efs.name]:
                sts,efs.structures = efs.structures[:nst],efs.structures[nst:]
                scs,efs.scores = efs.scores[:nst],efs.scores[nst:]
                idx = numpy.array(list(sts[0])) != '-'
                tseq = seq[idx].tostring()
                for i in range(nst):
                    sts[i] = sts[i].replace('-','')
                print >>fsfh, rsq.FastS(tid,tseq,sts,scs)
                if args.efdfile:
                    print >>fdfh, rsq.FastD(tid,tseq,FDS[efs.name].loops[idx],FDS[efs.name].stems[idx])
    if args.efdfile:
        fdfh.close()

def fastSMerge(args):
    '''
    Merge FastS files.
    Parameters:
        args.infiles: list of strings
            A list of FastC files
        args.outfile: string
            Output file.
    '''
    FS = collections.OrderedDict()
    for i in range(len(args.infiles)):
        for fs in rsq.IO.FastSReader(args.infiles[i]):
            if FS.has_key(fs.name):
                FS[fs.name].structures.extend(fs.structures)
                FS[fs.name].scores.extend(fs.scores)
            else:
                FS[fs.name] = fs
    # output
    with ngslib.mFile(args.outfile, 'w') as ofh:
        for name in FS:
            print >>ofh, FS[name]

def init(args):
    ''' store the counter for later use '''
    global counter
    counter = args

def sfoldext(fc,N,fn,wdir,keep):
    ''' write sfold result to file. '''
    success = True
    try:
        fs = rsq.Predictor.sfoldext(fc,37,0,N=N,workdir=wdir,keep=keep)
        global lock
        with lock:
            with ngslib.mFile(fn,'aw') as ofh:
                ofh.write("{0}\n".format(fs))
                #ofh.flush()
    except IOError as e:
        print >> sys.stderr, "\r{0}".format(e)
        success = False
    global counter
    counter.value += 1
    if counter.value % 2 == 0:
        print >> sys.stderr, "Processed {0} items ...      \r".format(counter.value),
    return success

def parseFold(args):
    '''
    Fold structures using sfold given FastC.
    '''
    print >> sys.stderr, "Start to fold with {0} CPUs ...".format(args.p)
    # multiprocess
    freeze_support()
    global counter
    counter = Value('i', 0)
    global lock
    lock = Lock()
    # check working directory
    args.wdir = os.path.expanduser(args.wdir)
    if not os.path.isdir(args.wdir):
        os.makedirs(args.wdir)

    # create empty file
    with ngslib.mFile(args.outfile,'w') as ofh:
        pass
    FCS = list(rsq.IO.FastCReader(args.infile))
    pool = Pool(processes=args.p,initializer = init, initargs = (counter,))
    pool.map(functools.partial(sfoldext,N=args.n,fn=args.outfile,wdir=args.wdir,keep=args.keep), FCS)
    print >> sys.stderr, "Processed {0} items.      ".format(counter.value)
    if not args.keep:
        shutil.rmtree(args.wdir, ignore_errors=True)
    return

def quantify(args):
    '''
    Quantification of RNA structure dynamics using RNA footprinting data.
    Parameters:
        args.fdfile: string
            FastD file.
        args.fsfile: string
            FastS or EFastS file.
        args.isoform: string
            Isoform file generated by 'rsq FastS extend'. \
            Only required when EFastS file is used as input.
        args.expression: string, optional
            Expression file in format: geneid   isoform1    exprs1  \
            isoform1    exprs2  ...
        args.maxiter: int
            Maximum number of iterations.
        args.threshold: float
            Threshold for EM algorithm termination.
        args.outfile: string
            Output file.
    '''
    # Isoform
    isoform  = collections.OrderedDict()
    if args.isoform:
        for line in ngslib.IO.BioReader(args.isoform):
            isoform[line[0]] = dict((line[2*i+1],int(line[2*i+2])) for i in range(len(line)/2))
            #isoform[line[0]] = {line[2*i+1]:int(line[2*i+2]) for i in range(len(line)/2)}
    # Expression constraints
    exprs = collections.OrderedDict()
    if args.expression:
        for line in ngslib.IO.BioReader(args.expression):
            exprs[line[0]] = dict((line[2*i+1],int(line[2*i+2])) for i in range(len(line)/2))
            #exprs[line[0]] = {line[2*i+1]:int(line[2*i+2]) for i in range(len(line)/2)}
    # FastD file
    FDs = collections.OrderedDict()
    for fd in rsq.IO.FastDReader(args.fdfile):
        FDs[fd.name] = fd
    # FastS file
    with ngslib.mFile(args.outfile,'w') as ofh:
        print >>ofh, "geneID\tPercentages\tloop_reads\tstem_reads"
        for fs in rsq.IO.FastSReader(args.fsfile):
            if isoform.has_key(fs.name) and len(isoform[fs.name]) >1: # has isoforms
                pass
                # Add code here
            else:
                fd = FDs[fs.name]
                Pi,muS,muV = rsq.Algorithm.EM(fd,fs,None,None,args.threshold,args.maxiter)
            print >>ofh, "{0}\t{1}\t{2}\t{3}".format(fs.name,';'.join(numpy.round(Pi,3).astype('str')),';'.join(numpy.round(muS,3).astype('str')),';'.join(numpy.round(muV,3).astype('str')))

def draw(args):
    ''' Draw figure given FastS. '''
    for fs in rsq.IO.FastSReader(args.infile):
        if args.suffix:
            fs.name += '_'+args.suffix
        rsq.Utils.draw(fs,args.format)

def parseFitness(args):
    ''' Calculate fitness between FastD and FastS. '''
    with ngslib.mFile(args.outfile,'w') as fitofh:
        fitofh.write("#name\tloopFit\tstemFit\tfitness\tnumOfStruct\n")
        # read FastS
        FS = collections.OrderedDict()
        duplicate = collections.OrderedDict()
        print >> sys.stderr, "Reading FastS file: {0} ...".format(args.fsfile)
        i0 = 0
        for fs in rsq.IO.FastSReader(args.fsfile):
            key = fs.seq if args.byseq else fs.name
            if not FS.has_key(key):
                FS[key] = fs
            else:
                print >> sys.stderr, "Warning: Ignoring duplicate FastD key: {0}".format(key)
                duplicate [key] = 1
            i0 += 1
            if i0 % 100 == 0:
                print >> sys.stderr, "Processed {0} items ...      \r".format(i0),
        print >> sys.stderr, "Processed {0} items.".format(i0)
        print >> sys.stderr
        # Remove duplicate keys
        for key in duplicate:
            FS.pop(key,None)
        # read FastD
        i0 = 0
        i1 = 0
        print >> sys.stderr, "Reading and processing FastD file: {0} ...".format(args.fdfile)
        for fd in rsq.IO.FastDReader(args.fdfile):
            i0 += 1
            if i0 % 10 == 0:
                print >> sys.stderr, "Processed {0} items ...      \r".format(i0),
            tfs = FS.get(fd.seq if args.byseq else fd.name, None)
            if tfs is None: continue
            sloops, sstems = sum(fd.loops),sum(fd.stems)
            depth = 1.0*(sloops+sstems)/len(fd)
            if sloops == 0 or sstems ==0:
                depth *= 2.
            if depth >= args.coverage:
                i1 += 1
                fitscore = rsq.Algorithm.fitness(fd,tfs,args.threshold)
                fitofh.write("{0}\t{1}\t{2}\t{3}\t{4}\n".format(fd.name,fitscore[0],fitscore[1],fitscore[2],numpy.sum(tfs.scores>args.threshold)))
        print >> sys.stderr, "Processed {0} items.".format(i0)
        print >> sys.stderr
        print >> sys.stderr, "{0} items passed coverage (>={1}) filter.".format(i1,args.coverage)
        print >> sys.stderr, "Fitness scores for {0} items were written into {1}.".format(i1,args.outfile)
    return

def version():
    ''' get version. '''
    return pkg_resources.get_distribution("rsq").version 

class ThreadSafeFile(object):
    def __init__(self, fname, mode):
        self.fn = fname
        self.fh = ngslib.mFile(self.fn,mode)
        self._lock = Lock()
    def write(self,lstr):
        with self._lock:
            self.fh.write(lstr)
            self.fh.flush()
    def __enter__(self):
        return self
    def __exit__(self,etype,value,traceback):
        if self.fn != "stdout":
            self.fh.close()

# ------------------------------------
# Classes
# ------------------------------------

# ------------------------------------
# Main
# ------------------------------------

if __name__=="__main__":
    method,args = ArgParser(sys.argv)
    methods = {'genFastD':fastDGenerate,'FastC':{'generate':fastCGenerate,'merge':fastCMerge},'FastS':{'generate':parseFold,'merge':fastSMerge},'draw':draw,'fitness':parseFitness,'quantify':quantify,'isoform':{'extend':isoformExtend,'split':isoformSplit}}
    prog = methods
    for k in method:
        prog = prog[k]
    prog(args)
